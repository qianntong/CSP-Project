import itertools as it
import numpy as np

# The bubble sort algorithm is what we are basing our reshuffles upon. It determines the process where, if the containers are removed in 
# priority order, how many additional moves would need to be made.
def bubble_sort(col):   # input: column of the container stacking bay
    Ylen = len(col)     # length of column  
    swaps = 0           # initialize swaps
    for j in range(Ylen):   # loop over column
        for k in range(0, Ylen-j-1):    # loop over future elements in the column
            if col[k] < col[k+1]:       # if there is a container otu of order...
                col[k], col[k+1] = col[k+1], col[k] #swap it...
                swaps += 1              # and count the swap necessary
    return swaps                        # return the number of swaps, which we refer to as reshuffles

# This array is for the creation of states. It deletes all elements in the array that are equal to 0.
def zero_delete(arr):
    N = len(arr)                # length of array
    new_arr = np.array([])      # the new array with no 0s
    for i in range (0, N):      # loop over array
        if arr[i] != 0:         # if not equal to 0...
            new_arr = np.append(new_arr, arr[i]) # new array appends the nonzero value
    while len(new_arr) > N:             # I forget what this does, but at one point in time it was relevent
        new_arr = np.append(new_arr, 0) # yeah still no clue, but I'm afraid to delete it
    return new_arr              # returns new array with no 0s

# The heart of the state generation process. It takes the order of containers and generates the possible states. 
# For use in the first iteration
def main(Containers, B):        # Inputs are containers and columns (B)
    Clen = len(Containers)      # Length of array
    C_next = Containers[-1]     # The container we are grabbing is the last one for the backwards induction
    Containers_1 = np.delete(Containers, Clen-1)    # Delete the last container from the array; states generated come from the remainder
    Sort_cons = np.sort(Containers_1)   # Sort the remaining containers
    Slen = len(Sort_cons)               # Length of the new sorted containers
    Iter_combos = {}                    # Dictionary for the combinations of containers that can go together
    for i in range (1, Slen+1):         # Loop over sorted containers
        Iter_combos[i] = it.combinations(Sort_cons, r = i)  # Itertools library to make combinations
    Stack_combos = {}   # Dictionary to store combinations of stacks
    j = 0               # Initialize stack dictionary indexing
    for i in range(1, Slen+1):      # Loop over sorted containers
        for IC in Iter_combos[i]:   # Loop over combinations
            IC_array = np.array(IC) # Turn into numpy array as these are easiest to work with
            Stack_combos[j] = IC_array  # New array for stack combinations
            j += 1                      # Add 1 to indexing
    N = len(Stack_combos)   # Length of combinations array
    N1 = int(N-1)           # Length 1 is the above length subtract 1
    N12 = int(N1/2)         # Length N12 is N1/2
    Stack_pairs = {}        # Initialize dictionary
    for i in range(0, N12): # Because we want unique solutions, only iteration through the first half of combos and...
        for j in range(N12, N1):    # Compare them to the second half of the combos
            if len(np.intersect1d(Stack_combos[i], Stack_combos[j])) == 0:  # Intersection tells if the combination is valid
                Stack_pairs[i] = Stack_combos[i], Stack_combos[j]           # Add to dictionary
    Stack_pairs[N12] = np.zeros(Slen), Stack_combos[N-1]    # Create array to store pairs
    NSP = len(Stack_pairs)  # Length of total stack pairs
    states = [0]*(NSP)      # Choices of states depends on length of state pairs
    for i in Stack_pairs:   # Loop over stack pairs
        couple = Stack_pairs[i]
        L = len(couple)
        new_couple = [0]*B
        for j in range(0, L):
            element = np.sort(couple[j])[::-1]
            while len(element) < Slen:
                element = np.append(element, 0)
            new_couple[j] = element
        states[i] = new_couple
    shuffles = np.zeros((NSP, B))
    for i in range(0, NSP):
        for j in range(0,B):
            column = states[i][j]
            column = np.append(column, C_next)
            column = zero_delete(column)        # Zero_delete helps ensure 0s are not counted in the bubble_sort
            value = bubble_sort(column.copy())  # bubble_sort returns the number of reshufles
            shuffles[i][j] = value              # Update shuffles matrix
    return shuffles, states # Return states and shuffles for the given container input
    
# The outputs from above are in terms of a list of arrays. Change this into a matrix for better data manipulation
def matx_gen(listarr):
    matx_list = [0]*len(listarr)
    i = 0
    for L in listarr:
        matx_list[i] = np.column_stack((L[0], L[1]))
        i += 1
    return matx_list

# Removes the input container from a matrix
def removal(MX, r): # Inputs are the state, MX, and the removed container, r
    matx  = MX.copy()   # Copy the matrix
    row, col = matx.shape   # Find dimensions
    for i in range(0, row): # Loop over rows
        for j in range(0, col): # Loop over columns
            if matx[i, j] == r: # If an element is equal to the containe rof interest...
                matx[i, j] = 0  # Change to 0
    for j in range(0, row):     # Loop over remaining elements
        matx[j] = np.sort(matx[j])[::-1] #Sort them to remove the new space vacated by the 0
    return matx #return new matrix with the container removed

# Creates dictionary of states to make indexing easier
def dict_gen(matx, shuffles, level): # Inputs are matrix, the corresponding shuffles, and the level in the process this state is at
    nodes = {}
    Mlen = len(matx)
    count = 1
    for i in range (0, Mlen):
        index = str(level)+str(count)
        nodes[int(index)] = (matx[i].T, shuffles[i].T)
        count += 1
    return nodes

def equivalency(MX1, MX2):
    if np.array_equal(MX1, MX2) == True:
        return True
    elif np.array_equal(np.flip(MX1, axis = 0), MX2) == True:
        return True
    else:
        return False

def upper(nodes, level):
    a = int(str(level+1)+"1")
    U = {}
    for i in nodes:
        u = {}
        for j in nodes[i][1]:
            u[a] = j
            a += 1
        U[i] = u
    return U

def lower(state, con, col):
    stat = state.copy()
    choice = (stat[col]==0).argmax(axis=0)
    stat[col][choice] = con
    count = 0
    for i in stat:
        count += bubble_sort(i)
    return count

def row_finder(state, con):
    Tlen = len(state)
    for i in range(0, Tlen):
        if con in state[i]:
            return i
        

def next_state(nodes, level, con):
    a = int(str(level-1)+"1")
    S = {}
    V = {}
    L = len(nodes)
    keys = np.array([])
    for i in nodes:
        keys = np.append(keys, i)
    for i in range(0, L):
        for j in range(i+1, L):
            truth = equivalency(removal(nodes[keys[i]][0], con), removal(nodes[keys[j]][0], con))
            if truth == True:
                nodei = nodes[keys[i]][0]
                nodej = nodes[keys[j]][0]
                rnodei = removal(nodei, con)
                rnodej = removal(nodej, con)
                rowi = row_finder(nodei, con)
                rowj = row_finder(nodej, con)
                loweri = lower(rnodei, con, rowi)
                lowerj = lower(rnodej, con, rowj)
                S[a] = removal(nodej, con), np.array([loweri, lowerj])
                V[a] = {keys[i]: loweri , keys[j]: lowerj}
                a += 1   
    return S, V


def looper(containers, level, columns):
    order = containers[::-1]
    Clen = len(containers)
    qshuffs, qstats = main(containers, columns)
    qnodes = dict_gen(matx_gen(qstats), qshuffs, level)
    states = qnodes
    res_dict = upper(qnodes, level)
    current_nodes, current_shuffs = qnodes, qshuffs
    for i in range(1, Clen):
        current_nodes, current_shuffs = next_state(current_nodes, level, order[i])
        level -= 1
        for i in current_nodes:
            res_dict[i] = current_shuffs[i]
            states[i] = current_nodes[i]
    return res_dict, states
        
q = np.array([4, 3, 1, 2])
print(looper(q, 3, 2))

