import itertools as it
import numpy as np

C = np.array([2, 1, 4, 3])
C_next = np.array([2, 1]) #stacking container 3


def bubble_sort(col):
    Ylen = len(col)
    swaps = 0
    for j in range(Ylen):
        for k in range(0, Ylen-j-1):
            if col[k] < col[k+1]:
                col[k], col[k+1] = col[k+1], col[k]
                swaps += 1
    return swaps

def zero_delete(arr):
    N = len(arr)
    new_arr = np.array([])
    for i in range (0, N):
        if arr[i] != 0:
            new_arr = np.append(new_arr, arr[i])
    while len(new_arr) > N:
        new_arr = np.append(new_arr, 0)
    return new_arr

def main(Containers, B):
    Clen = len(Containers)
    C_next = Containers[-1]
    Containers_1 = np.delete(Containers, Clen-1)
    Sort_cons = np.sort(Containers_1)
    Slen = len(Sort_cons)
    Iter_combos = {}
    for i in range (1, Slen+1):
        Iter_combos[i] = it.combinations(Sort_cons, r = i)
    Stack_combos = {}
    j = 0
    for i in range(1, Slen+1):
        for IC in Iter_combos[i]:
            IC_array = np.array(IC)     
            Stack_combos[j] = IC_array
            j += 1
    N = len(Stack_combos)
    N1 = int(N-1)
    N12 = int(N1/2)
    Stack_pairs = {}
    for i in range(0, N12):
        for j in range(N12, N1):
            if len(np.intersect1d(Stack_combos[i], Stack_combos[j])) == 0:
                Stack_pairs[i] = Stack_combos[i], Stack_combos[j]
    Stack_pairs[N12] = np.zeros(Slen), Stack_combos[N-1]
    NSP = len(Stack_pairs)
    big_list = [0]*(NSP)
    for i in Stack_pairs:
        couple = Stack_pairs[i]
        L = len(couple)
        new_couple = [0]*B
        for j in range(0, L):
            element = np.sort(couple[j])[::-1]
            while len(element) < Slen:
                element = np.append(element, 0)
            new_couple[j] = element
        #print(f" State {i} has {B} columns: column 0 is {new_couple[0]} and column 1 is {new_couple[1]}")
        big_list[i] = new_couple
    states = big_list
    shuffles = np.zeros((NSP, B))
    for i in range(0, NSP):
        for j in range(0,B):
            column = states[i][j]
            column = np.append(column, C_next)
            column = zero_delete(column)
            value = bubble_sort(column.copy())
            #print(f"If you place container {C_next} in column {j} of state {i} there will be {value} reshuffles")
            shuffles[i][j] = value
    return big_list

def matx_gen(listarr):
    matx_list = [0]*len(listarr)
    i = 0
    for L in listarr:
        matx_list[i] = np.column_stack((L[0][::-1], L[1][::-1]))
        i += 1
    return matx_list

q = np.array([2, 1, 4, 3])
r = np.array([2, 1, 4])
s = np.array([2, 1])

qmain = main(q, 2)
rmain = main(r, 2)
smain = main(s, 2)

print(matx_gen(qmain))
print(matx_gen(rmain))
print(matx_gen(smain))
